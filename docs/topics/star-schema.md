# Star Schema - Dimensional Modeling

> **AI-Generated Documentation**: This document was automatically generated to support learning and reference purposes. While the content is based on established dimensional modeling concepts and this project's architecture, please verify critical details against best practices for your specific use cases.

## Overview

Star Schema is a dimensional modeling technique where data is organized into fact tables (measures/metrics) surrounded by dimension tables (descriptive attributes). The schema resembles a star: fact table at center, dimensions radiating outward.

In this lakehouse platform's Gold layer ([Medallion Architecture](medallion-architecture.md)), [DBT](dbt.md) creates star schema models stored as [Apache Iceberg](apache-iceberg.md) tables, optimized for analytics queries via [Trino](trino.md).

## Why Star Schema?

**Query Performance**: Denormalized structure minimizes joins - fast aggregations.

**Business-Friendly**: Dimensions have descriptive names - analysts understand tables intuitively.

**BI Tool Optimization**: Tools like Tableau, PowerBI work best with star schemas.

**Scalability**: Add new dimensions without changing fact table structure.

**Maintainability**: Clear separation of facts (events) vs dimensions (attributes).

## Core Components

### 1. Fact Tables

**What it is**: Table storing measurable events/transactions (sales, clicks, orders)

**Characteristics**:
- **Grain**: One row per atomic event (e.g., one order line item)
- **Foreign keys**: References to dimensions (customer_key, product_key, date_key)
- **Measures**: Numeric values (quantity, amount, count)
- **Large volume**: Millions to billions of rows
- **Append-mostly**: New transactions added, rarely updated

**Example - fct_orders**:
```sql
CREATE TABLE gold.fct_orders (
    order_key BIGINT,              -- Surrogate key
    customer_key BIGINT,           -- FK to dim_customer
    product_key BIGINT,            -- FK to dim_product
    date_key INTEGER,              -- FK to dim_date
    order_id VARCHAR,              -- Business key
    quantity INTEGER,              -- Measure
    unit_price DECIMAL(10,2),      -- Measure
    total_amount DECIMAL(10,2),    -- Calculated measure
    order_date TIMESTAMP           -- Degenerate dimension
)
WITH (
    format = 'PARQUET',
    partitioning = ARRAY['date(order_date)']
);
```

**Fact types**:
- **Transaction**: One row per event (orders, clicks, payments)
- **Snapshot**: Periodic state capture (daily inventory, account balances)
- **Accumulating**: Process lifecycle (order → ship → deliver)

### 2. Dimension Tables

**What it is**: Table storing descriptive attributes (who, what, where, when)

**Characteristics**:
- **Descriptive**: Text fields (names, descriptions, categories)
- **Slowly changing**: Updates infrequent (customer address change)
- **Smaller volume**: Thousands to millions of rows
- **Denormalized**: Include hierarchies (country → state → city)

**Example - dim_customer**:
```sql
CREATE TABLE silver.dim_customer (
    customer_key BIGINT PRIMARY KEY,  -- Surrogate key
    customer_id VARCHAR,               -- Business key
    email VARCHAR,
    first_name VARCHAR,
    last_name VARCHAR,
    city VARCHAR,
    state VARCHAR,
    country VARCHAR,
    customer_segment VARCHAR,          -- Derived attribute
    valid_from TIMESTAMP,              -- SCD Type 2
    valid_to TIMESTAMP,                -- SCD Type 2
    is_current BOOLEAN                 -- SCD Type 2
)
WITH (
    format = 'PARQUET',
    partitioning = ARRAY['month(valid_from)']
);
```

**Common dimensions**:
- **dim_customer**: Who made purchase
- **dim_product**: What was purchased
- **dim_date**: When transaction occurred
- **dim_location**: Where transaction occurred
- **dim_employee**: Who processed transaction

### 3. Surrogate Keys

**What it is**: System-generated unique identifier (not business key)

**Why use surrogate keys?**
- **Handle changes**: Business keys change (customer email update)
- **Performance**: Integer keys faster for joins than varchar
- **SCD Type 2**: Track history of single entity
- **Multiple sources**: Same customer from different systems

**Natural key vs Surrogate key**:
```sql
-- Natural key (business key)
customer_id = 'CUST-12345'  -- Meaningful, from source system

-- Surrogate key
customer_key = 789  -- Meaningless integer, generated by warehouse
```

**Generate surrogate keys** in DBT:
```sql
{{ dbt_utils.surrogate_key(['customer_id', 'valid_from']) }} as customer_key
-- Generates: MD5(CONCAT(customer_id, '|', valid_from))
```

### 4. Slowly Changing Dimensions (SCD)

**Type 1: Overwrite** (no history):
```sql
-- Old record
customer_id=123, email=old@email.com

-- After update
customer_id=123, email=new@email.com  -- Old value lost
```

**Type 2: Add new row** (preserve history):
```sql
-- Old record
customer_key=1, customer_id=123, email=old@email.com, valid_from=2024-01-01, valid_to=2025-01-15, is_current=FALSE

-- New record
customer_key=2, customer_id=123, email=new@email.com, valid_from=2025-01-15, valid_to=NULL, is_current=TRUE
```

**Type 3: Add new column** (limited history):
```sql
customer_id=123, current_email=new@email.com, previous_email=old@email.com
```

**This project uses Type 2** (most common for dimensions).

## Example Star Schema

**Schema diagram**:
```
         dim_date
             |
             |
dim_customer --- fct_orders --- dim_product
                     |
                     |
                dim_location
```

**Query example**:
```sql
SELECT
    d.year,
    d.month_name,
    c.customer_segment,
    p.product_category,
    SUM(f.total_amount) as revenue,
    COUNT(DISTINCT f.customer_key) as unique_customers,
    COUNT(f.order_key) as order_count
FROM gold.fct_orders f
JOIN silver.dim_customer c ON f.customer_key = c.customer_key
JOIN silver.dim_product p ON f.product_key = p.product_key
JOIN silver.dim_date d ON f.date_key = d.date_key
WHERE d.year = 2025
  AND c.customer_segment = 'Premium'
GROUP BY d.year, d.month_name, c.customer_segment, p.product_category
ORDER BY d.month_name;
```

**Performance**: Fast query - limited joins, leverages partitioning.

## DBT Implementation

### Dimension Model

```sql
-- models/silver/dim_customer.sql
{{
  config(
    materialized='incremental',
    unique_key='customer_key',
    file_format='iceberg',
    partition_by=['month(valid_from)']
  )
}}

WITH source AS (
    SELECT * FROM {{ ref('stg_customers') }}
    {% if is_incremental() %}
    WHERE updated_at > (SELECT MAX(valid_from) FROM {{ this }})
    {% endif %}
),

with_surrogate_key AS (
    SELECT
        {{ dbt_utils.surrogate_key(['customer_id', 'updated_at']) }} as customer_key,
        customer_id,
        email,
        first_name,
        last_name,
        city,
        state,
        country,
        CASE
            WHEN lifetime_value > 10000 THEN 'Premium'
            WHEN lifetime_value > 1000 THEN 'Standard'
            ELSE 'Basic'
        END as customer_segment,  -- Derived attribute
        updated_at as valid_from,
        NULL::TIMESTAMP as valid_to,
        TRUE as is_current
    FROM source
)

SELECT * FROM with_surrogate_key
```

### Fact Model

```sql
-- models/gold/fct_orders.sql
{{
  config(
    materialized='incremental',
    unique_key='order_key',
    file_format='iceberg',
    partition_by=['date(order_date)']
  )
}}

SELECT
    {{ dbt_utils.surrogate_key(['o.order_id']) }} as order_key,
    c.customer_key,
    p.product_key,
    d.date_key,
    o.order_id,
    o.quantity,
    o.unit_price,
    o.quantity * o.unit_price as total_amount,
    o.order_date
FROM {{ ref('stg_orders') }} o
LEFT JOIN {{ ref('dim_customer') }} c
    ON o.customer_id = c.customer_id
    AND c.is_current = TRUE  -- Join to current dimension record
LEFT JOIN {{ ref('dim_product') }} p
    ON o.product_id = p.product_id
    AND p.is_current = TRUE
LEFT JOIN {{ ref('dim_date') }} d
    ON DATE(o.order_date) = d.date

{% if is_incremental() %}
WHERE o.order_date > (SELECT MAX(order_date) FROM {{ this }})
{% endif %}
```

### Date Dimension (Pre-Built)

```sql
-- models/silver/dim_date.sql
{{ config(materialized='table') }}

WITH date_spine AS (
    {{ dbt_utils.date_spine(
        datepart="day",
        start_date="cast('2020-01-01' as date)",
        end_date="cast('2030-12-31' as date)"
    ) }}
),

with_attributes AS (
    SELECT
        CAST(TO_CHAR(date_day, 'YYYYMMDD') AS INTEGER) as date_key,
        date_day as date,
        YEAR(date_day) as year,
        QUARTER(date_day) as quarter,
        MONTH(date_day) as month,
        DAY(date_day) as day,
        DAYOFWEEK(date_day) as day_of_week,
        DAYOFYEAR(date_day) as day_of_year,
        CASE DAYOFWEEK(date_day)
            WHEN 1 THEN 'Sunday'
            WHEN 2 THEN 'Monday'
            WHEN 3 THEN 'Tuesday'
            WHEN 4 THEN 'Wednesday'
            WHEN 5 THEN 'Thursday'
            WHEN 6 THEN 'Friday'
            WHEN 7 THEN 'Saturday'
        END as day_name,
        CASE MONTH(date_day)
            WHEN 1 THEN 'January'
            WHEN 2 THEN 'February'
            -- ... etc
            WHEN 12 THEN 'December'
        END as month_name,
        CASE
            WHEN DAYOFWEEK(date_day) IN (1, 7) THEN FALSE
            ELSE TRUE
        END as is_weekday
    FROM date_spine
)

SELECT * FROM with_attributes
```

## Best Practices

### 1. Always Use Surrogate Keys

**Good**:
```sql
customer_key BIGINT PRIMARY KEY  -- Surrogate key
customer_id VARCHAR              -- Business key
```

**Bad**:
```sql
customer_id VARCHAR PRIMARY KEY  -- Natural key as primary key
```

### 2. Implement SCD Type 2 for Dimensions

Track history for audit/analysis:
```sql
valid_from TIMESTAMP
valid_to TIMESTAMP
is_current BOOLEAN
```

### 3. Denormalize Dimensions

Include hierarchies in dimension tables:
```sql
-- Good: Denormalized
dim_customer: city, state, country

-- Bad: Normalized (requires joins)
dim_customer → dim_city → dim_state → dim_country
```

### 4. Pre-Calculate Measures in Facts

```sql
-- Good: Pre-calculated
total_amount = quantity * unit_price

-- Bad: Calculate at query time
SELECT quantity * unit_price as total_amount  -- Slower
```

### 5. Use Conformed Dimensions

Share dimensions across fact tables:
```sql
fct_orders → dim_customer
fct_support_tickets → dim_customer  -- Same dimension!
```

## Query Patterns

### Simple Aggregation

```sql
SELECT
    SUM(total_amount) as total_revenue,
    COUNT(*) as order_count
FROM gold.fct_orders;
```

### Group by Dimension

```sql
SELECT
    c.customer_segment,
    SUM(f.total_amount) as revenue
FROM gold.fct_orders f
JOIN silver.dim_customer c ON f.customer_key = c.customer_key
WHERE c.is_current = TRUE
GROUP BY c.customer_segment;
```

### Time Series

```sql
SELECT
    d.year,
    d.month_name,
    SUM(f.total_amount) as monthly_revenue
FROM gold.fct_orders f
JOIN silver.dim_date d ON f.date_key = d.date_key
GROUP BY d.year, d.month, d.month_name
ORDER BY d.year, d.month;
```

### Historical Analysis (SCD Type 2)

```sql
-- Revenue by customer segment as of specific date
SELECT
    c.customer_segment,
    SUM(f.total_amount) as revenue
FROM gold.fct_orders f
JOIN silver.dim_customer c
    ON f.customer_key = c.customer_key
    AND f.order_date BETWEEN c.valid_from AND COALESCE(c.valid_to, CURRENT_TIMESTAMP)
WHERE f.order_date = DATE '2025-01-15'
GROUP BY c.customer_segment;
```

## Integration with Other Components

- **[DBT](dbt.md)**: Creates star schema models
- **[Medallion Architecture](medallion-architecture.md)**: Star schema implemented in Gold layer
- **[Apache Iceberg](apache-iceberg.md)**: Stores fact and dimension tables
- **[Trino](trino.md)**: Queries star schema models

## References

- [Kimball Dimensional Modeling](https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/)
- [DBT - Dimensional Modeling](https://docs.getdbt.com/terms/dimensional-modeling)
- [Star Schema Benchmark](http://www.tpc.org/tpcds/)
- Project Setup Guide: [SETUP_GUIDE.md](../../SETUP_GUIDE.md)
